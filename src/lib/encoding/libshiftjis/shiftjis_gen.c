/*
 * Shift_JIS table generator
 *
 * Reads the WHATWG index-jis0208.txt file and generates a C header
 * containing:
 *   1. The JIS X 0208 decode table (pointer → Unicode)
 *   2. The JIS X 0208 encode table (Unicode → pointer) for encoding
 *
 * Usage: shiftjis_gen <input_dir> <output_file>
 *
 * The input_dir should contain index-jis0208.txt (from
 * https://encoding.spec.whatwg.org/index-jis0208.txt).
 *
 * The table sizes are derived from the input file at build time.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* Entry for the encode table: maps Unicode code point to pointer */
typedef struct {
    uint16_t codepoint;
    uint16_t pointer;
} EncodeEntry;

/* Comparison function for sorting by codepoint */
static int cmp_encode_entry(const void *a, const void *b)
{
    const EncodeEntry *ea = (const EncodeEntry *)a;
    const EncodeEntry *eb = (const EncodeEntry *)b;
    if (ea->codepoint < eb->codepoint) return -1;
    if (ea->codepoint > eb->codepoint) return 1;
    /* Prefer lower pointer for same codepoint (per WHATWG) */
    if (ea->pointer < eb->pointer) return -1;
    if (ea->pointer > eb->pointer) return 1;
    return 0;
}

int main(int argc, char **argv)
{
    FILE *fin, *fout;
    char line[512];
    char inpath[1024];
    int count = 0;
    int max_pointer = -1;
    int table_size;
    uint16_t *decode_table;
    EncodeEntry *encode_entries;
    int encode_count = 0;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input_dir> <output_file>\n", argv[0]);
        return 1;
    }

    snprintf(inpath, sizeof(inpath), "%s/index-jis0208.txt", argv[1]);

    /* First pass: find the maximum pointer value and count entries */
    fin = fopen(inpath, "r");
    if (!fin) {
        fprintf(stderr, "Cannot open %s\n", inpath);
        return 1;
    }

    while (fgets(line, sizeof(line), fin)) {
        int pointer;
        unsigned int codepoint;

        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r')
            continue;

        if (sscanf(line, " %d\t0x%X", &pointer, &codepoint) == 2) {
            if (pointer > max_pointer)
                max_pointer = pointer;
            count++;
        }
    }
    fclose(fin);

    if (max_pointer < 0) {
        fprintf(stderr, "shiftjis_gen: no entries found in %s\n", inpath);
        return 1;
    }

    table_size = max_pointer + 1;
    decode_table = calloc(table_size, sizeof(uint16_t));
    encode_entries = calloc(count, sizeof(EncodeEntry));
    if (!decode_table || !encode_entries) {
        fprintf(stderr, "shiftjis_gen: out of memory\n");
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    /* Second pass: populate the tables */
    fin = fopen(inpath, "r");
    if (!fin) {
        fprintf(stderr, "Cannot open %s\n", inpath);
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    while (fgets(line, sizeof(line), fin)) {
        int pointer;
        unsigned int codepoint;

        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r')
            continue;

        if (sscanf(line, " %d\t0x%X", &pointer, &codepoint) == 2) {
            if (pointer >= 0 && pointer < table_size) {
                decode_table[pointer] = (uint16_t)codepoint;
                encode_entries[encode_count].codepoint = (uint16_t)codepoint;
                encode_entries[encode_count].pointer = (uint16_t)pointer;
                encode_count++;
            }
        }
    }
    fclose(fin);

    /* Sort encode entries by codepoint for binary search */
    qsort(encode_entries, encode_count, sizeof(EncodeEntry), cmp_encode_entry);

    /* Remove duplicate codepoints (keep first, i.e., lowest pointer) */
    int unique_count = 0;
    for (int i = 0; i < encode_count; i++) {
        if (unique_count == 0 || encode_entries[i].codepoint != encode_entries[unique_count - 1].codepoint) {
            encode_entries[unique_count++] = encode_entries[i];
        }
    }
    encode_count = unique_count;

    fprintf(stderr, "shiftjis_gen: read %d decode entries (max pointer %d), %d unique encode entries\n",
            count, max_pointer, encode_count);

    fout = fopen(argv[2], "w");
    if (!fout) {
        fprintf(stderr, "Cannot open %s for writing\n", argv[2]);
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    fprintf(fout, "/* Auto-generated by shiftjis_gen from index-jis0208.txt. Do not edit. */\n\n");

    /* Decode table */
    fprintf(fout, "#define JIS0208_TABLE_SIZE %d\n\n", table_size);
    fprintf(fout, "static const uint16_t jis0208_table[JIS0208_TABLE_SIZE] = {\n");

    for (int i = 0; i < table_size; i++) {
        if (i % 16 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "0x%04X,", decode_table[i]);
        if (i % 16 == 15 || i == table_size - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n\n");

    /* Encode table (sorted by codepoint for binary search) */
    fprintf(fout, "#define JIS0208_ENCODE_SIZE %d\n\n", encode_count);
    fprintf(fout, "typedef struct {\n");
    fprintf(fout, "    uint16_t codepoint;\n");
    fprintf(fout, "    uint16_t pointer;\n");
    fprintf(fout, "} JIS0208EncodeEntry;\n\n");
    fprintf(fout, "static const JIS0208EncodeEntry jis0208_encode_table[JIS0208_ENCODE_SIZE] = {\n");

    for (int i = 0; i < encode_count; i++) {
        if (i % 4 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "{0x%04X, %5d},", encode_entries[i].codepoint, encode_entries[i].pointer);
        if (i % 4 == 3 || i == encode_count - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n");

    fclose(fout);
    free(decode_table);
    free(encode_entries);

    return 0;
}

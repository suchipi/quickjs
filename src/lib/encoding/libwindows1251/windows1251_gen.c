/*
 * Windows-1251 table generator
 *
 * Reads the WHATWG index-windows-1251.txt file and generates a C header
 * containing:
 *   1. The decode table (pointer → Unicode)
 *   2. The encode table (Unicode → byte) for encoding
 *
 * Usage: windows1251_gen <input_dir> <output_file>
 *
 * The input_dir should contain index-windows-1251.txt
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 128

/* Entry for the encode table: maps Unicode code point to byte */
typedef struct {
    unsigned int codepoint;
    unsigned char byte;
} EncodeEntry;

/* Comparison function for sorting by codepoint */
static int cmp_encode_entry(const void *a, const void *b)
{
    const EncodeEntry *ea = (const EncodeEntry *)a;
    const EncodeEntry *eb = (const EncodeEntry *)b;
    if (ea->codepoint < eb->codepoint) return -1;
    if (ea->codepoint > eb->codepoint) return 1;
    return 0;
}

int main(int argc, char **argv)
{
    FILE *fin, *fout;
    char line[512];
    char inpath[1024];
    unsigned int decode_table[TABLE_SIZE];
    EncodeEntry encode_entries[TABLE_SIZE];
    int encode_count = 0;
    int i;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input_dir> <output_file>\n", argv[0]);
        return 1;
    }

    snprintf(inpath, sizeof(inpath), "%s/index-windows-1251.txt", argv[1]);

    /* Initialize decode table to 0 (unmapped) */
    memset(decode_table, 0, sizeof(decode_table));

    fin = fopen(inpath, "r");
    if (!fin) {
        fprintf(stderr, "Cannot open %s\n", inpath);
        return 1;
    }

    while (fgets(line, sizeof(line), fin)) {
        int pointer;
        unsigned int codepoint;

        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r')
            continue;

        if (sscanf(line, " %d\t0x%X", &pointer, &codepoint) == 2) {
            if (pointer >= 0 && pointer < TABLE_SIZE) {
                decode_table[pointer] = codepoint;
                encode_entries[encode_count].codepoint = codepoint;
                encode_entries[encode_count].byte = (unsigned char)(0x80 + pointer);
                encode_count++;
            }
        }
    }
    fclose(fin);

    /* Sort encode entries by codepoint for binary search */
    qsort(encode_entries, encode_count, sizeof(EncodeEntry), cmp_encode_entry);

    fprintf(stderr, "windows1251_gen: read %d entries\n", encode_count);

    fout = fopen(argv[2], "w");
    if (!fout) {
        fprintf(stderr, "Cannot open %s for writing\n", argv[2]);
        return 1;
    }

    fprintf(fout, "/* Auto-generated by windows1251_gen from index-windows-1251.txt. Do not edit. */\n\n");

    /* Decode table */
    fprintf(fout, "#define WINDOWS1251_TABLE_SIZE %d\n\n", TABLE_SIZE);
    fprintf(fout, "static const unsigned int windows1251_decode_table[WINDOWS1251_TABLE_SIZE] = {\n");

    for (i = 0; i < TABLE_SIZE; i++) {
        if (i % 8 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "0x%04X,", decode_table[i]);
        if (i % 8 == 7 || i == TABLE_SIZE - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n\n");

    /* Encode table (sorted by codepoint for binary search) */
    fprintf(fout, "#define WINDOWS1251_ENCODE_SIZE %d\n\n", encode_count);
    fprintf(fout, "typedef struct {\n");
    fprintf(fout, "    unsigned int codepoint;\n");
    fprintf(fout, "    unsigned char byte;\n");
    fprintf(fout, "} Windows1251EncodeEntry;\n\n");
    fprintf(fout, "static const Windows1251EncodeEntry windows1251_encode_table[WINDOWS1251_ENCODE_SIZE] = {\n");

    for (i = 0; i < encode_count; i++) {
        if (i % 4 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "{0x%04X, 0x%02X},", encode_entries[i].codepoint, encode_entries[i].byte);
        if (i % 4 == 3 || i == encode_count - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n");

    fclose(fout);
    return 0;
}

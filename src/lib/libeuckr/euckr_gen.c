/*
 * EUC-KR table generator
 *
 * Reads the WHATWG index-euc-kr.txt file and generates a C header
 * containing:
 *   1. The decode table (pointer → Unicode)
 *   2. The encode table (Unicode → pointer) for encoding
 *
 * Usage: euckr_gen <input_dir> <output_file>
 *
 * The input_dir should contain index-euc-kr.txt
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Entry for the encode table: maps Unicode code point to pointer */
typedef struct {
    unsigned int codepoint;
    unsigned int pointer;
} EncodeEntry;

/* Comparison function for sorting by codepoint */
static int cmp_encode_entry(const void *a, const void *b)
{
    const EncodeEntry *ea = (const EncodeEntry *)a;
    const EncodeEntry *eb = (const EncodeEntry *)b;
    if (ea->codepoint < eb->codepoint) return -1;
    if (ea->codepoint > eb->codepoint) return 1;
    /* Prefer lower pointer for same codepoint */
    if (ea->pointer < eb->pointer) return -1;
    if (ea->pointer > eb->pointer) return 1;
    return 0;
}

int main(int argc, char **argv)
{
    FILE *fin, *fout;
    char line[512];
    char inpath[1024];
    int count = 0;
    int max_pointer = -1;
    int table_size;
    unsigned int *decode_table;
    EncodeEntry *encode_entries;
    int encode_count = 0;
    int i;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input_dir> <output_file>\n", argv[0]);
        return 1;
    }

    snprintf(inpath, sizeof(inpath), "%s/index-euc-kr.txt", argv[1]);

    /* First pass: find the maximum pointer value and count entries */
    fin = fopen(inpath, "r");
    if (!fin) {
        fprintf(stderr, "Cannot open %s\n", inpath);
        return 1;
    }

    while (fgets(line, sizeof(line), fin)) {
        int pointer;
        unsigned int codepoint;

        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r')
            continue;

        if (sscanf(line, " %d\t0x%X", &pointer, &codepoint) == 2) {
            if (pointer > max_pointer)
                max_pointer = pointer;
            count++;
        }
    }
    fclose(fin);

    if (max_pointer < 0) {
        fprintf(stderr, "euckr_gen: no entries found in %s\n", inpath);
        return 1;
    }

    table_size = max_pointer + 1;
    decode_table = calloc(table_size, sizeof(unsigned int));
    encode_entries = calloc(count, sizeof(EncodeEntry));
    if (!decode_table || !encode_entries) {
        fprintf(stderr, "euckr_gen: out of memory\n");
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    /* Second pass: populate the tables */
    fin = fopen(inpath, "r");
    if (!fin) {
        fprintf(stderr, "Cannot open %s\n", inpath);
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    while (fgets(line, sizeof(line), fin)) {
        int pointer;
        unsigned int codepoint;

        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r')
            continue;

        if (sscanf(line, " %d\t0x%X", &pointer, &codepoint) == 2) {
            if (pointer >= 0 && pointer < table_size) {
                decode_table[pointer] = codepoint;
                encode_entries[encode_count].codepoint = codepoint;
                encode_entries[encode_count].pointer = pointer;
                encode_count++;
            }
        }
    }
    fclose(fin);

    /* Sort encode entries by codepoint for binary search */
    qsort(encode_entries, encode_count, sizeof(EncodeEntry), cmp_encode_entry);

    /* Remove duplicate codepoints (keep first, i.e., lowest pointer) */
    int unique_count = 0;
    for (i = 0; i < encode_count; i++) {
        if (unique_count == 0 || encode_entries[i].codepoint != encode_entries[unique_count - 1].codepoint) {
            encode_entries[unique_count++] = encode_entries[i];
        }
    }
    encode_count = unique_count;

    fprintf(stderr, "euckr_gen: read %d decode entries (max pointer %d), %d unique encode entries\n",
            count, max_pointer, encode_count);

    fout = fopen(argv[2], "w");
    if (!fout) {
        fprintf(stderr, "Cannot open %s for writing\n", argv[2]);
        free(decode_table);
        free(encode_entries);
        return 1;
    }

    fprintf(fout, "/* Auto-generated by euckr_gen from index-euc-kr.txt. Do not edit. */\n\n");

    /* Decode table */
    fprintf(fout, "#define EUCKR_TABLE_SIZE %d\n\n", table_size);
    fprintf(fout, "static const unsigned int euckr_decode_table[EUCKR_TABLE_SIZE] = {\n");

    for (i = 0; i < table_size; i++) {
        if (i % 8 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "0x%04X,", decode_table[i]);
        if (i % 8 == 7 || i == table_size - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n\n");

    /* Encode table (sorted by codepoint for binary search) */
    fprintf(fout, "#define EUCKR_ENCODE_SIZE %d\n\n", encode_count);
    fprintf(fout, "typedef struct {\n");
    fprintf(fout, "    unsigned int codepoint;\n");
    fprintf(fout, "    unsigned int pointer;\n");
    fprintf(fout, "} EUCKREncodeEntry;\n\n");
    fprintf(fout, "static const EUCKREncodeEntry euckr_encode_table[EUCKR_ENCODE_SIZE] = {\n");

    for (i = 0; i < encode_count; i++) {
        if (i % 4 == 0)
            fprintf(fout, "    ");
        fprintf(fout, "{0x%04X, %5d},", encode_entries[i].codepoint, encode_entries[i].pointer);
        if (i % 4 == 3 || i == encode_count - 1)
            fprintf(fout, "\n");
        else
            fprintf(fout, " ");
    }
    fprintf(fout, "};\n");

    fclose(fout);
    free(decode_table);
    free(encode_entries);

    return 0;
}
